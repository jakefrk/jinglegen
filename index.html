<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JingleGen</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; display: flex; justify-content: center; }
        .app-container { width: 90%; max-width: 1200px; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h1 { text-align: center; color: #333; }
        .upload-area { 
            border: 2px dashed #3399ff; 
            padding: 0; 
            text-align: center; 
            margin: 0 auto 20px auto; 
            cursor: pointer; 
            width: 300px;
            height: 200px;
            background: linear-gradient(135deg, #e0f2ff 0%, #b3e0ff 100%);
            box-shadow: 0 0 24px 0 rgba(51,153,255,0.18), 0 2px 8px 0 rgba(51,153,255,0.10);
            border-radius: 18px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: box-shadow 0.2s, border-color 0.2s;
        }
        .upload-area:hover { 
            border-color: #005fa3; 
            box-shadow: 0 0 32px 0 rgba(51,153,255,0.28), 0 4px 16px 0 rgba(51,153,255,0.18);
        }
        .upload-area p {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .upload-area .subtext {
            font-size: 1.2em;
            font-weight: 500;
            margin-bottom: 8px;
        }
        .upload-area .emojis {
            font-size: 1.5em;
            letter-spacing: 0.2em;
            margin-top: 2px;
            color: #3399ff;
        }
        #fileName { margin-bottom: 10px; font-style: italic; text-align: center;}
        .results-container { display: flex; flex-direction: row; gap: 20px; }
        .results-column { flex: 1; padding: 15px; background-color: #e9e9e9; border-radius: 4px; }
        .results-column h2 { margin-top: 0; font-size: 1.2em; }
        .results-column pre { white-space: pre-wrap; font-family: monospace; font-size: 0.9em; background-color: #fdfdfd; padding: 10px; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="container">
            <h1>JingleGen</h1>
            <h2>Audio-to-RTB </h2>
            
            <div class="upload-area" id="dropZone">
                <p>Drop Audio File Here</p>
                <div class="subtext">&lt;5 seconds.</div>
                <div class="emojis">‚ô´‚ãÜÔΩ°‚ô™ ‚ÇäÀö‚ô¨ Ôæü. ùÑû</div>
                <input type="file" id="fileInput" accept="audio/*" style="display: none;">
            </div>
            <p id="fileName"></p>
        </div>

        <div class="results-container">
            <div class="results-column" id="analysisResultsArea">
                <h2>Raw Audio Analysis:</h2>
                <pre id="rawAnalysisOutput">Analysis details will appear here...</pre>
            </div>
            <div class="results-column" id="ortbRequestArea">
                <h2>Mock ORTB Bid Request:</h2>
                <pre id="ortbRequestOutput">ORTB request will appear here...</pre>
            </div>
        </div>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const rawAnalysisOutput = document.getElementById('rawAnalysisOutput');
        const ortbRequestOutput = document.getElementById('ortbRequestOutput');
        
        const MAX_FILE_SIZE_MB = 5;
        const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
        const API_ENDPOINT = "https://tmh3m4cmuk.execute-api.us-east-2.amazonaws.com/prod";

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = '#333'; });
        dropZone.addEventListener('dragleave', () => { dropZone.style.borderColor = '#ccc'; });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#ccc';
            if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) handleFile(e.target.files[0]);
        });

        function displayError(message, area = "raw") {
            const errorMsg = `<span style="color: red;">Error: ${message}</span>`;
            if (area === "raw" || area === "both") rawAnalysisOutput.innerHTML = errorMsg;
            if (area === "ortb" || area === "both") ortbRequestOutput.innerHTML = errorMsg;
            fileNameDisplay.textContent = '';
        }

        function formatRawAnalysisForDisplay(analysisData) {
            let textString = "MOOD & ENERGY:\n";
            textString += `  Energy Level: ${analysisData.mood_energy?.interpreted_energy || 'N/A'}\n`;
            textString += `  Brightness: ${analysisData.mood_energy?.interpreted_brightness || 'N/A'}\n`;
            textString += `  Spectral Rolloff: ${analysisData.mood_energy?.spectral_rolloff?.toFixed(2) || 'N/A'}\n`;
            textString += `  Spectral Bandwidth: ${analysisData.mood_energy?.spectral_bandwidth?.toFixed(2) || 'N/A'}\n\n`;

            textString += "INSTRUMENT ANALYSIS:\n";
            textString += `  Instrument Type: ${analysisData.instrument_analysis?.interpreted_instrument_type || 'N/A'}\n`;
            textString += `  Harmonic Ratio: ${analysisData.instrument_analysis?.harmonic_ratio?.toFixed(2) || 'N/A'}\n`;
            textString += `  Mean Harmonic Energy: ${analysisData.instrument_analysis?.harmonic_energy_mean?.toExponential(2) || 'N/A'}\n`;
            textString += `  Mean Percussive Energy: ${analysisData.instrument_analysis?.percussive_energy_mean?.toExponential(2) || 'N/A'}\n\n`;

            textString += "MUSICAL CHARACTERISTICS:\n";
            textString += `  Tempo: ${analysisData.musical_characteristics?.tempo_bpm || 'N/A'} BPM\n`;
            textString += `  Style: ${analysisData.musical_characteristics?.interpreted_style || 'N/A'}\n`;
            textString += `  Mean Onset Strength: ${analysisData.musical_characteristics?.onset_strength_mean?.toFixed(2) || 'N/A'}\n\n`;

            textString += "RHYTHM ANALYSIS:\n";
            textString += `  Beat Density: ${analysisData.rhythm_analysis?.interpreted_beat_density || 'N/A'}\n`;
            textString += `  Onset Count: ${analysisData.rhythm_analysis?.onset_count || 'N/A'}\n`;
            textString += `  Rhythm Density (Onsets/sec): ${analysisData.rhythm_analysis?.rhythm_density_onsets_per_sec?.toFixed(2) || 'N/A'}\n\n`;
            
            // New Transcription Section
            textString += "TRANSCRIPTION:\n";
            textString += `  Transcribed Text: ${analysisData.transcription?.text || '(Transcription pending implementation)'}\n`;

            return textString;
        }

        async function handleFile(file) {
            fileNameDisplay.textContent = `Selected file: ${file.name}`;
            rawAnalysisOutput.textContent = `Processing ${file.name}...`;
            ortbRequestOutput.textContent = `Waiting for analysis...`;

            if (!file.type.startsWith('audio/')) {
                displayError("Invalid file type. Please upload an audio file.", "both");
                return;
            }
            if (file.size > MAX_FILE_SIZE_BYTES) {
                displayError(`File is too large. Maximum size is ${MAX_FILE_SIZE_MB}MB.`, "both");
                return;
            }
            
            const audio = new Audio(URL.createObjectURL(file));
            audio.onloadedmetadata = async () => {
                URL.revokeObjectURL(audio.src);
                if (audio.duration > 5) {
                    displayError("Audio duration is too long. Maximum is ~2-5 seconds.", "both");
                    return;
                }

                try {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = async () => {
                        const base64Audio = reader.result.split(',')[1];
                        rawAnalysisOutput.textContent = `Uploading and analyzing ${file.name}...`;
                        
                        if (API_ENDPOINT === "YOUR_API_GATEWAY_ENDPOINT_URL_HERE") {
                            rawAnalysisOutput.innerHTML = `<span style="color: orange;">API Endpoint not configured. Displaying mock data.</span><br><br>`;
                            setTimeout(() => {
                                const mockAudioFeatures = {
                                    "mood_energy": {"interpreted_energy": "High", "interpreted_brightness": "Bright", "spectral_rolloff": 3500.50, "spectral_bandwidth": 2200.75},
                                    "instrument_analysis": {"interpreted_instrument_type": "Melodic", "harmonic_ratio": 0.75, "harmonic_energy_mean": 0.05, "percussive_energy_mean": 0.01},
                                    "musical_characteristics": {"tempo_bpm": 136, "interpreted_style": "Fast-paced", "onset_strength_mean": 1.5},
                                    "rhythm_analysis": {"interpreted_beat_density": "Medium", "onset_count": 4, "rhythm_density_onsets_per_sec": 2.0},
                                    "transcription": {"text": "JingleGen radio, playing all the hits! Get your demo today."}
                                };

                                const mockSelectedSignalsForOrtb = {
                                    "energy_level": mockAudioFeatures.mood_energy.interpreted_energy,
                                    "brightness": mockAudioFeatures.mood_energy.interpreted_brightness,
                                    "instrument_type": mockAudioFeatures.instrument_analysis.interpreted_instrument_type,
                                    "tempo_bpm": mockAudioFeatures.musical_characteristics.tempo_bpm,
                                    "style": mockAudioFeatures.musical_characteristics.interpreted_style,
                                    "beat_density": mockAudioFeatures.rhythm_analysis.interpreted_beat_density,
                                    "onset_count": mockAudioFeatures.rhythm_analysis.onset_count,
                                    "transcribed_text_snippet": (mockAudioFeatures.transcription.text || "").substring(0, 256)
                                };

                                const mockOrtbRequest = {
                                    "id": `mock-bid-${new Date().getTime()}`,
                                    "imp": [{
                                        "id": "1",
                                        "audio": {"mimes": ["audio/mpeg", "audio/wav"], "minduration": 1, "maxduration": 5},
                                        "ext": {
                                            "custom_audio_signals": mockSelectedSignalsForOrtb
                                        }
                                    }],
                                    "app": {
                                        "id": "jinglegen-app-v1", "name": "JingleGen Demo", "bundle": "com.example.jinglegen",
                                        "publisher": {"id": "pub-12345", "name": "JingleGen Publisher"}
                                    },
                                    "device": {"ua": "Chrome/100.0", "ip": "192.168.1.10", "devicetype": 2, "os": "MacOS"},
                                    "user": {"id": "test-user-001"},
                                    "at": 1,
                                    "tmax": 200,
                                    "regs": {"ext": {"gdpr": 0}}
                                };

                                const currentMessage = rawAnalysisOutput.innerHTML;
                                rawAnalysisOutput.textContent = formatRawAnalysisForDisplay(mockAudioFeatures);
                                rawAnalysisOutput.innerHTML = currentMessage + rawAnalysisOutput.textContent;

                                ortbRequestOutput.textContent = JSON.stringify(mockOrtbRequest, null, 2);
                            }, 500);
                            return;
                        }

                        const response = await fetch(API_ENDPOINT, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ 
                                fileName: file.name,
                                fileType: file.type,
                                audioData: base64Audio 
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: response.statusText }));
                            throw new Error(`API Error (${response.status}): ${errorData.error}`);
                        }

                        const data = await response.json();
                        // ... handle response ...
                    };
                } catch (err) {
                    displayError(err.message, "both");
                }
            };
        }
    </script>
</body>
</html> 